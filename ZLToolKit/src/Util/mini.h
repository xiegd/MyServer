/*
 * mini.h - 一个简单的 INI 文件解析器
 * 用于读写配置文件，支持分节存储和类型转换
 */

#ifndef UTIL_MINI_H
#define UTIL_MINI_H

#include <cctype>    // 用于字符处理
#include <fstream>   // 文件操作
#include <map>       // 存储键值对
#include <string>    // 字符串处理
#include <vector>    // 动态数组
#include "util.h"    // 工具函数

namespace toolkit {

// minimal ini 解析器
// mINI_basic 类：INI 文件的基本解析器
// 继承自 std::map，用于存储配置项
template <typename key, typename variant>
class mINI_basic : public std::map<key, variant> {
    // Public API : existing map<> interface plus following methods
   public:
    // 解析 INI 格式的文本内容
    void parse(const std::string &text) {
        // 将文本按行分割
        std::vector<std::string> lines = tokenize(text, "\n");
        std::string symbol, tag;
        
        for (auto &line : lines) {
            // 去除行首尾空白
            line = trim(line);
            
            // 忽略空行和注释行（以 ; 或 # 开头）
            if (line.empty() || line.front() == ';' || line.front() == '#') {
                continue;
            }
            
            // 处理节名 [section]
            if (line.size() >= 3 && line.front() == '[' && line.back() == ']') {
                tag = trim(line.substr(1, line.size() - 2));
            } else {
                // 处理键值对 key=value
                auto at = line.find('=');
                // 组合完整的键名：section.key
                symbol = trim(tag + "." + line.substr(0, at));
                // 存储键值对
                (*this)[symbol] = (at == std::string::npos ? 
                                 std::string() : trim(line.substr(at + 1)));
            }
        }
    }

    // 从文件读取并解析 INI 内容
    void parseFile(const std::string &fileName = exePath() + ".ini") {
        // 以二进制模式打开文件
        std::ifstream in(fileName, 
                        std::ios::in | std::ios::binary | std::ios::ate);
        if (!in.good()) {
            throw std::invalid_argument("Invalid ini file: " + fileName);
        }
        
        // 读取文件内容
        auto size = in.tellg();
        in.seekg(0, std::ios::beg);
        std::string buf;
        buf.resize(size);
        in.read((char *)buf.data(), size);
        parse(buf);
    }

    // 将配置内容转换为 INI 格式的文本, 存在string中
    // 可以指定头尾注释
    // footer页脚，header页眉
    std::string dump(
        const std::string &header = "; auto-generated by mINI class {",
        const std::string &footer = "; } ---") const {
        std::string front(header + (header.empty() ? "" : "\r\n")), output, tag;
        std::vector<std::string> kv;
        
        // 遍历所有配置项
        for (auto &pr : *this) {
            // 分离节名和键名
            auto pos = pr.first.find('.');  // 处理section.key格式
            if (pos == std::string::npos) {
                kv = {"", pr.first};
            } else {
                kv = {pr.first.substr(0, pos), pr.first.substr(pos + 1)};
            }
            
            // 处理无节名的配置项
            if (kv[0].empty()) {
                front += kv[1] + "=" + pr.second + "\r\n";
                continue;
            }
            
            // 添加新节名
            if (tag != kv[0]) {
                output += "\r\n[" + (tag = kv[0]) + "]\r\n";
            }
            // 添加键值对
            output += kv[1] + "=" + pr.second + "\r\n";
        }
        return front + output + "\r\n" + footer +
               (footer.empty() ? "" : "\r\n");
    }

    // 将配置保存到文件
    void dumpFile(const std::string &fileName = exePath() + ".ini") {
        // trunc: 截断文件，如果文件存在，则清空文件内容
        // out: 文件输出模式标志，表示打开的文件能用于写入操作
        std::ofstream out(fileName,
                         std::ios::out | std::ios::binary | std::ios::trunc);
        auto dmp = dump();
        out.write(dmp.data(), dmp.size());
    }

    // 获取单例实例
    static mINI_basic &Instance();

   private:
    // 将字符串按指定分隔符分割成token
    std::vector<std::string> tokenize(const std::string &self,
                                    const std::string &chars) const {
        std::vector<std::string> tokens(1);
        std::string map(256, '\0');  // 只包含所有的ASCII字符
        // 建立分隔符映射表
        for (char ch : chars) {
            map[(uint8_t)ch] = '\1';  // 标记分隔符位置
        }
        // 分割字符串
        for (char ch : self) {
            // 如果不是分隔符，则添加到当前token中
            if (!map.at((uint8_t)ch)) {
                tokens.back().push_back(ch);
            } else if (tokens.back().size()) {
                // 如果是分隔符，则说明下面的是一个新的token
                // 往tokens中添加一个新的空字符串，存储下一个token
                tokens.push_back(std::string());
            }
        }
        // 移除末尾空token
        while (tokens.size() && tokens.back().empty()) {
            tokens.pop_back();
        }
        return tokens;
    }
};

// variant 类：用于存储不同类型的值
struct variant : public std::string {
    // 从数值类型构造
    template <typename T>
    variant(const T &t) : std::string(std::to_string(t)) {}

    // 从字符数组构造, 使用模板处理不同长度的char[], 编译时确定长度
    template <size_t N>
    variant(const char (&s)[N]) : std::string(s, N) {}

    // 从C风格字符串构造, 运行时确定长度
    variant(const char *cstr) : std::string(cstr) {}

    // 从string构造
    variant(const std::string &other = std::string()) : std::string(other) {}

    // 类型转换操作符, 将variant转换为T类型，
    // 会根据T是否为类类型调用不同的转换函数
    template <typename T>
    operator T() const {
        return as<T>();
    }

    // 比较操作符, 调用string的compare方法
    template <typename T>
    bool operator==(const T &t) const {
        return 0 == this->compare(variant(t));
    }

    // 与C风格字符串比较
    bool operator==(const char *t) const { return this->compare(t) == 0; }

    // 非类类型的转换
    template <typename T>
    typename std::enable_if<!std::is_class<T>::value, T>::type as() const {
        return as_default<T>();
    }

    // 类类型的转换
    template <typename T>
    typename std::enable_if<std::is_class<T>::value, T>::type as() const {
        return T((const std::string &)*this);
    }

   private:
    // 默认类型转换实现
    template <typename T>
    T as_default() const {
        T t;
        std::stringstream ss;
        // 将string写入流，从流中读取T类型变量，从ss读取会自动进行类型转换
        // 如果写入流和从中读取都成功，返回T类型变量，否则返回T(), 即默认构造的T
        return ss << *this && ss >> t ? t : T();
    }
};

// bool类型的特化实现
template <>
bool variant::as<bool>() const;

// uint8_t类型的特化实现
template <>
uint8_t variant::as<uint8_t>() const;

// 定义常用的 INI 类型
using mINI = mINI_basic<std::string, variant>;

}  // namespace toolkit
#endif  // UTIL_MINI_H
